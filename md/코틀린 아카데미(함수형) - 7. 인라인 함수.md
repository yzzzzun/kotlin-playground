
``` kotlin
fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {  
    var accumulator = initial  
    for (element in this) accumulator = operation(accumulator, element)  
    return accumulator  
}

fun main() {  
    val students = listOf(  
        Student("Alice", 20, 90),  
        Student("Bob", 22, 85),  
        Student("Charlie", 21, 95),  
    )  
  
    val points = students.fold(0) { acc, student ->  
        acc + student.polint  
    }
    println("Total points: $points")  
}
```

fold ë‚´ forë¬¸ê³¼ ì™¸ë¶€ ëŒë‹¤ì‹ì„ ë„˜ë‚˜ë“¤ë©´ì„œ ì‹¤í–‰ë¨
ì ì€ ë¹„ìš©ì´ì§€ë§Œ ìŒ“ì´ë©´ ë¹„ìš©ì´ ì¦ê°€í•¨

ê·¸ë˜ì„œ ìë°”ê°€ í•¨ìˆ˜í˜•ì„ ì§€ì›í•˜ì§€ ì•Šê¸¸ ë°”ë¼ëŠ” ê°œë°œìë“¤ì´ ë§ìœ¼ë©° ì„ ì–¸ì ì¸ í”„ë¡œê·¸ë˜ë°ì„ í•˜ê²Œë¨
``` java
for(student in students) {
	points += student.point
}
```

ì¸ë¼ì¸ í•¨ìˆ˜ëŠ” ëŒë‹¤ í‘œí˜„ì‹ì„ í˜¸ì¶œí•˜ëŠ” ë¹„ìš©ì„ ì—†ì• ì¤Œ

---
# ì¸ë¼ì¸ í•¨ìˆ˜
inline ì œì–´ìê°€ ë¶™ì€ í•¨ìˆ˜ëŠ” ë‹¤ë¥¸ í•¨ìˆ˜ë“¤ê³¼ ë‹¤ë¥´ê²Œ í˜¸ì¶œë˜ì§€ ì•ŠìŒ
ëŒ€ì‹  ì»´íŒŒì¼ í•  ë•Œ í•¨ìˆ˜ ë³¸ë¬¸ì´ í˜¸ì¶œì ìª½ì— ë³µì‚¬ë˜ì–´ ë“¤ì–´ê°

ì¸ë¼ì¸ í•¨ìˆ˜ì˜ ì¥ì 
- í•¨ìˆ˜í˜• ë§¤ê°œë³€ìˆ˜ê°€ ìˆëŠ” í•¨ìˆ˜ë©´ ì¸ë¼ì¸ ë˜ì—ˆì„ë•Œ íš¨ìœ¨ì ì„
- ë¹„ì§€ì—­(non-local) ë°˜í™˜ì´ í—ˆìš©ë¨
- íƒ€ì… ì¸ìˆ˜ê°€ êµ¬ì²´í™”(reified)ë¨

---
# í•¨ìˆ˜í˜• ë§¤ê°œë³€ìˆ˜ê°€ ìˆëŠ” ì¸ë¼ì¸ í•¨ìˆ˜
ì¸ë¼ì¸ í•¨ìˆ˜ê°€ í•¨ìˆ˜ íƒ€ì…ì˜ ë§¤ê°œë³€ìˆ˜ë¥¼ ë°›ëŠ”ë‹¤ë©´ ë§¤ê°œë³€ìˆ˜ë„ ê¸°ë³¸ì ìœ¼ë¡œ ì¸ë¼ì¸ì´ ë¨

``` kotlin

fun main() {  
	/*
	val points = students.fold(0) { acc, student ->  
        acc + student.polint  
    }
    println("Total points: $points")  
	*/
    var accumulator = 0
    for (element in Students) accumulator = accumulator + element.point
    val points = accumulator
    println("Total points: $points")  
}
```

í•¨ìˆ˜í˜• ë§¤ê°œë³€ìˆ˜ê°€ ìˆëŠ” ìµœìƒìœ„ í•¨ìˆ˜ë¥¼ ì¸ë¼ì¸ìœ¼ë¡œ ë§Œë“œëŠ”ê²ƒì€ ê´€í–‰ì´ë¨

ì¸ë¼ì¸ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œ ì‚¬ìš©ë˜ëŠ” ëŒë‹¤ í‘œí˜„ì‹ì€ ê°ì²´ë¥¼ ìƒì„±í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ
- ì¸ë¼ì¸ì´ ì•„ë‹ˆë©´ FunctionX ì¸í„°í˜ì´ìŠ¤ì˜ ê°ì²´ í˜•íƒœë¡œ ìƒì„±ë¨
ì¸ë¼ì¸ì´ ì•„ë‹Œ í•¨ìˆ˜ì—ëŠ” ì—†ëŠ” ê¸°ëŠ¥ì´ ìƒê²¨ë‚¨ ë¹„ì§€ì—­ ë°˜í™˜

---
# ë¹„ì§€ì—­ ë°˜í™˜

ëŒë‹¤ í‘œí˜„ì‹ì—ì„œëŠ” ì œì–´êµ¬ì¡°ì˜ í•œê³„ê°€ ìˆìŒ
``` kotlin
fun main() {
	repeat(10){ index ->  
	    if(index == 4) return  
	    println(index)  
	}  
	  
	for( i in 0 until 20){  
	    if(i== 4) return  
	    println(i)  
	}
}
```
main í•¨ìˆ˜ê°€ ì¢…ë£Œë˜ì–´ ë²„ë¦¼

í•˜ì§€ë§Œ ì¸ë¼ì¸ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ ëŒë‹¤ í‘œí˜„ì‹ ì•ˆì—ì„œ returnì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ
ì»´íŒŒì¼ ì‹œì ì— ì½”ë“œê°€ ì‚½ì…ë¨
ì½”í‹€ë¦°ì—ì„œ ì»¬ë ‰ì…˜ ì²˜ë¦¬ í•¨ìˆ˜ ë˜í•œ ì¸ë¼ì¸ì´ê¸° ë•Œë¬¸ì— ë¹„ì§€ì—­ ë°˜í™˜ì„ ì§€ì›í•¨ (map, forEach, filter ë“±)

ê·¸ëŸ¼ JavaëŠ”..?
Javaì˜ ëŒë‹¤ëŠ” ìµëª…í´ë˜ìŠ¤ ê¸°ë°˜ì˜ ê°ì²´ì„
ë‹¨ìˆœí•˜ê²Œ ê°’ì˜ ë°˜í™˜ ìš©ë„ì„

---
# crossinline ê³¼ noinline

crossinline : ì¸ë¼ì¸ì€ ë˜ì§€ë§Œ, ë¹„ì§€ì—­ ë°˜í™˜ì€ í—ˆìš©í•˜ì§€ ì•ŠìŒ
ì¸ë¼ì¸ì‹œ ë¹„ì§€ì—­ ë°˜í™˜ì„ í—ˆìš©í–ˆì„ë•Œ ì˜í–¥ë„ê°€ ìˆëŠ”ê±¸ ë§‰ê¸° ìœ„í•¨
``` kotlin
inline fun doWork(crossinline block: () -> Unit) {
    val runnable = Runnable {
        block() // âŒ return ê¸ˆì§€
    }
    runnable.run()
}

fun main() {
    doWork {
        println("Inside crossinline block")
        // return  // ğŸš« ì»´íŒŒì¼ ì—ëŸ¬: return ê¸ˆì§€!
    }
}

fun main() {
    val runnable = Runnable {
        println("Inside crossinline block")
        // return  âŒ ì—¬ê¸´ Runnable.run()ì´ê¸° ë•Œë¬¸ì—, returnì´ mainì— ì˜í–¥ì„ ì£¼ë©´ ì•ˆ ë¨
    }
    runnable.run()
}
```

noinline : ì¸ë¼ì¸ì„ í—ˆìš©í•˜ì§€ ì•ŠìŒ
inlineí•˜ì§€ ì•Šê² ë‹¤? -> í•¨ìˆ˜ë¥¼ ê°ì²´ì²˜ëŸ¼ ì‚¬ìš©ê°€ëŠ¥í•¨
``` kotlin
inline fun doWork(
    block1: () -> Unit,
    noinline block2: () -> Unit
) {
    block1()           // âœ… ì¸ë¼ì¸ë¨
    val copy = block2  // âœ… ê°ì²´ë¡œ ì°¸ì¡° ê°€ëŠ¥
    copy()
}

fun main() {
    doWork(
        { println("Inline block1") },
        { println("Non-inline block2") }
    )
}

fun main() {
    println("Inline block1")
    val copy = object : Function0<Unit> {
        override fun invoke() {
            println("Non-inline block2")
        }
    }
    copy.invoke()
}
```
---
# êµ¬ì²´í™”ëœ íƒ€ì… ë§¤ê°œë³€ìˆ˜

í•¨ìˆ˜ë¥¼ ì¸ë¼ì¸ìœ¼ë¡œ ë§Œë“¤ê³  íƒ€ì… ë§¤ê°œë³€ìˆ˜ì— reified ì œì–´ìë¥¼ ë¶™ì´ë©´ íƒ€ì…ì— ëŒ€í•œ ì‘ì—…ì´ ê°€ëŠ¥í•¨
``` kotlin
fun < T> printTypeName(){
	print(T::class.simpleName) // ì»´íŒŒì¼ ì—ëŸ¬
}

inline fun < reified T> printTypeName(){  
    print(T::class.simpleName)  
}
```

ë¼ì´ë¸ŒëŸ¬ë¦¬ ì œì‘ìì—ê²Œ ì¤‘ìš”í•œ ê°œë…

---
# ì¸ë¼ì¸ í”„ë¡œí¼í‹°
í”„ë¡œí¼í‹°ì—ë„ inline ì œì–´ìë¥¼ ë¶™ì¼ ìˆ˜ ìˆìŒ
ì¸ë¼ì¸ í”„ë¡œí¼í‹°ëŠ” ì½”ë“œì— ì˜í–¥ì„ì¤Œ
ì •ë§ ì €ìˆ˜ì¤€ì˜ ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•œê²ƒì´ ì•„ë‹ˆë¼ë©´ ì‚¬ìš©ì•ˆí•¨

---
# ì¸ë¼ì¸ í”„ë¡œí¼í‹°ì˜ ë¹„ìš©
ì¸ë¼ì¸ì€ ìœ ìš©í•œ ì œì–´ìì„. í•˜ì§€ë§Œ ê·¸ì—ë”°ë¥¸ ë¬¸ì œë„ ìˆìŒ

- ì¸ë¼ì¸ í•¨ìˆ˜ëŠ” ê°€ì‹œì„±ì´ ì œí•œëœ ì›ì†Œë¥¼ ì‚¬ìš©í•  ìˆ˜ì—†ìŒ
- ì¸ë¼ì¸ì€ ì¬ê·€ë¡œ êµ¬í˜„í•  ìˆ˜ ì—†ìŒ
	- ì¬ê·€ í•¨ìˆ˜ì—ëŠ” **inline ëŒ€ì‹  tailrec (ê¼¬ë¦¬ ì¬ê·€)** ê³ ë ¤  (ì»´íŒŒì¼ëŸ¬ê°€ ì¬ê·€ë£¨í”„ë¡œ ë°”ê¿”ì¤Œ)
- ì¸ë¼ì¸ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ ì½”ë“œì–‘ì´ ë§ì•„ì§

ì¸ë¼ì¸ í•¨ìˆ˜ë¡œ ì¸í•´ ì½”ë“œì–‘ì´ ë§ì•„ì§€ë©´ ë­ê°€ë¬¸ì œì•¼?
- í´ë˜ìŠ¤ íŒŒì¼ í¬ê¸°ê°€ ì»¤ì§ -> ìºì‹œ ë¯¸ìŠ¤ ì¦ê°€
- JVM JIT ì»´íŒŒì¼ëŸ¬ì˜ ìµœì í™” ì–´ë ¤ì›Œì§.(ê°œë°œìê°€ ë¬´ì¡°ê±´ inlineí•˜ë©´ Jitê°€ íŒë‹¨í•  ì—¬ì§€ë¥¼ ì—†ì• ë²„ë¦¼)
- ë¡œë”© ì‹œê°„ ì¦ê°€


ì£¼ë¡œ ë‘ê°€ì§€ ì¼€ì´ìŠ¤ì— ì‚¬ìš©í•¨
- í•¨ìˆ˜í˜• ë§¤ê°œë³€ìˆ˜ë¥¼ ë°›ëŠ” í•¨ìˆ˜ì˜ ì„±ëŠ¥ ê°œì„ (ë¹„ì§€ì—­ ë°˜í™˜)
- êµ¬ì²´í™”ëœ íƒ€ì…ì˜ ë§¤ê°œë³€ìˆ˜ ì§€ì›(reified)